<h1>dcv.imgproc.convolution</h1>
           Module introduces <a target="_blank" href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution">image <u id="convolution">convolution</u></a> function.
<br><br>
Following example loads famous image of Lena SÃ¶derberg and performs gaussian blurring by convolving the image with gaussian kernel.
<br><br>

<pre class="d_code"><font color=blue>import</font> dcv.io.image : imread, ReadParams;
<font color=blue>import</font> dcv.core.image : Image, asType;
<font color=blue>import</font> dcv.imgproc.<u id="convolution">convolution</u> : conv;

Image lenaImage = imread(<font color=red>"../data/lena.png"</font>, ReadParams(ImageFormat.IF_MONO, BitDepth.BD_8));
<font color=blue>auto</font> slice = lenaImage.sliced!<font color=blue>ubyte</font>;
</pre>
<br><br>

... this loads the following image:<br>
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/data/lena.png?raw=true"/>
<br><br>

<pre class="d_code">blurred = slice
             .asType!<font color=blue>float</font> <font color=green>// convert ubyte data to float.
</font>             .conv(gaussian!<font color=blue>float</font>(0.84f, 5, 5)); <font color=green>// convolve image with gaussian kernel
</font>
</pre>
<br><br>

... which give the resulting image:<br>
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/filter/result/outblur.png?raw=true"/>
<br><br>


<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.<br><br>

<dl><dt><big><a name="conv"></a>Slice!(N, InputType*) <u id="conv">conv</u>(alias bc = neumann, InputType, KernelType, MaskType = InputType, size_t N, size_t NK)(Slice!(N, InputType*) <i>range</i>, Slice!(NK, KernelType*) <i>kernel</i>, Slice!(N, InputType*) <i>prealloc</i> = emptySlice!(N, InputType), Slice!(NK, MaskType*) <i>mask</i> = emptySlice!(NK, MaskType), TaskPool <i>pool</i> = taskPool);
</big></dt>
<dd>Perform convolution to given <i>range</i>, using given <i>kernel</i>.
Convolution is supported for 1, 2, and 3D slices.
<br><br>
<b>Params:</b><br>
<table><tr><td>bc</td>
<td>(Template parameter) Boundary Condition function used while indexing the image matrix.</td></tr>
<tr><td>Slice!(N, InputType*) <i>range</i></td>
<td>Input <i>range</i> slice (1D, 2D, and 3D slice supported)</td></tr>
<tr><td>Slice!(NK, KernelType*) <i>kernel</i></td>
<td>Convolution <i>kernel</i> slice. For 1D <i>range</i>, 1D <i>kernel</i> is expected.
    For 2D <i>range</i>, 2D kernele is expected. For 3D <i>range</i>, 2D or 3D <i>kernel</i> is expected -
    if 2D <i>kernel</i> is given, each item in <i>kernel</i> matrix is applied to each value in
    corresponding 2D coordinate in the <i>range</i>.</td></tr>
<tr><td>Slice!(N, InputType*) <i>prealloc</i></td>
<td>Pre-allocated array where convolution result can be stored. Default
    value is emptySlice, where resulting array will be newly allocated. Also if
    <i>prealloc</i> is not of same shape as input <i>range</i>, resulting array will be newly allocated.</td></tr>
<tr><td>Slice!(NK, MaskType*) <i>mask</i></td>
<td>Masking <i>range</i>. Convolution will skip each element where <i>mask</i> is 0. Default value
    is empty slice, which tells that convolution will be performed on the whole <i>range</i>.</td></tr>
<tr><td>TaskPool <i>pool</i></td>
<td>Optional TaskPool instance used to parallelize computation.</td></tr>
</table><br>
<b>Returns:</b><br>
Slice of resulting image after convolution.<br><br>

</dd>
</dl>

           <div id="contributors"></div>
           <hr>Copyright Relja Ljubobratovic 2016.


