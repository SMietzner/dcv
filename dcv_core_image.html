<h1>dcv.core.image</h1>
           Module implements Image utility class, and basic API for <u id="image">image</u> manipulation.
<br><br>
Image class encapsulates <u id="image">image</u> properties with minimal functionality. It is primarily designed to be used as I/O unit.
For any <u id="image">image</u> processing needs, <u id="image">image</u> data can be sliced to mir.ndslice.slice.Slice.

<br><br>
<b>Example:</b><br>
<pre class="d_code">Image <u id="image">image</u> = <font color=blue>new</font> Image(32, 32, ImageFormat.IF_MONO, BitDepth.BD_32);

Slice!(3, <font color=blue>float</font>*) slice = <u id="image">image</u>.sliced!<font color=blue>float</font>; <font color=green>// slice image data, considering the data is of float type.
</font>
<font color=blue>assert</font>(<u id="image">image</u>.height == slice.length!0 &amp;&amp; <u id="image">image</u>.width == slice.length!1);
<font color=blue>assert</font>(<u id="image">image</u>.channels == 1);

<u id="image">image</u> = slice.asImage(ImageFormat.IF_MONO); <font color=green>// create the image back from sliced data.
</font></pre>

<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.<br><br>

<dl><dt><big><a name="ImageFormat"></a>enum <u id="ImageFormat">ImageFormat</u>: int;
</big></dt>
<dd>Image (pixel) format.<br><br>

<dl><dt><big><a name="ImageFormat.IF_UNASSIGNED"></a><u id="IF_UNASSIGNED">IF_UNASSIGNED</u></big></dt>
<dd>Not assigned format.<br><br>

</dd>
<dt><big><a name="ImageFormat.IF_MONO"></a><u id="IF_MONO">IF_MONO</u></big></dt>
<dd>Mono, single channel format.<br><br>

</dd>
<dt><big><a name="ImageFormat.IF_MONO_ALPHA"></a><u id="IF_MONO_ALPHA">IF_MONO_ALPHA</u></big></dt>
<dd>Mono with alpha channel.<br><br>

</dd>
<dt><big><a name="ImageFormat.IF_RGB"></a><u id="IF_RGB">IF_RGB</u></big></dt>
<dd>RGB format.<br><br>

</dd>
<dt><big><a name="ImageFormat.IF_BGR"></a><u id="IF_BGR">IF_BGR</u></big></dt>
<dd>BGR format.<br><br>

</dd>
<dt><big><a name="ImageFormat.IF_YUV"></a><u id="IF_YUV">IF_YUV</u></big></dt>
<dd>YUV (YCbCr) format.<br><br>

</dd>
<dt><big><a name="ImageFormat.IF_RGB_ALPHA"></a><u id="IF_RGB_ALPHA">IF_RGB_ALPHA</u></big></dt>
<dd>RGB format with alpha.<br><br>

</dd>
<dt><big><a name="ImageFormat.IF_BGR_ALPHA"></a><u id="IF_BGR_ALPHA">IF_BGR_ALPHA</u></big></dt>
<dd>BGR format with alpha.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="BitDepth"></a>enum <u id="BitDepth">BitDepth</u>: ulong;
</big></dt>
<dd>Bit depth of a pixel in an image.<br><br>

<dl><dt><big><a name="BitDepth.BD_UNASSIGNED"></a><u id="BD_UNASSIGNED">BD_UNASSIGNED</u></big></dt>
<dd>Not assigned depth info.<br><br>

</dd>
<dt><big><a name="BitDepth.BD_8"></a><u id="BD_8">BD_8</u></big></dt>
<dd>8-bit (ubyte) depth type.<br><br>

</dd>
<dt><big><a name="BitDepth.BD_16"></a><u id="BD_16">BD_16</u></big></dt>
<dd>16-bit (ushort) depth type.<br><br>

</dd>
<dt><big><a name="BitDepth.BD_32"></a><u id="BD_32">BD_32</u></big></dt>
<dd>32-bit (float) depth type.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Image"></a>class <u id="Image">Image</u>;
</big></dt>
<dd><u id="Image">Image</u> abstraction type.<br><br>

<dl><dt><big><a name="Image.this"></a>pure this(in Image <i>copy</i>, bool <i>deepCopy</i> = false);
</big></dt>
<dd>Copy constructor.
<br><br>
<b>Params:</b><br>
<table><tr><td>Image <i>copy</i></td>
<td>Input image, which is copied into this image structure.</td></tr>
<tr><td>bool <i>deepCopy</i></td>
<td>if <b>false</b> (default) the data array will be referenced
        from <i>copy</i>, esle values will be copied to newly allocated array.</td></tr>
</table><br>

</dd>
<dt><big><a name="Image.this.2"></a>pure nothrow @safe this(size_t <i>width</i>, size_t <i>height</i>, ImageFormat <i>format</i> = ImageFormat.IF_RGB, BitDepth <i>depth</i> = BitDepth.BD_8, ubyte[] <i>data</i> = null);
</big></dt>
<dd>Construct an image by given size, <i>format</i> and bit <i>depth</i> information.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>width</i></td>
<td><i>width</i> of a newly created image.</td></tr>
<tr><td>size_t <i>height</i></td>
<td><i>height</i> of a newly created image.</td></tr>
<tr><td>ImageFormat <i>format</i></td>
<td><i>format</i> of a newly created image.</td></tr>
<tr><td>BitDepth <i>depth</i></td>
<td>bit <i>depth</i> of a newly created image.</td></tr>
<tr><td>ubyte[] <i>data</i></td>
<td>potential <i>data</i> of an image, pre-allocated. If not a <b>null</b>, <i>data</i> array
        has to be of correct size = <i>width</i>*<i>height</i>*channels*<i>depth</i>, where channels are
        defined by the <i>format</i>, and <i>depth</i> is counded in bytes.</td></tr>
</table><br>

</dd>
<dt><big><a name="Image.format"></a>const pure @property @safe auto <u id="format">format</u>();
</big></dt>
<dd>Get <u id="format">format</u> of an image.<br><br>

</dd>
<dt><big><a name="Image.width"></a>const pure @property @safe auto <u id="width">width</u>();
</big></dt>
<dd>Get height of an image.<br><br>

</dd>
<dt><big><a name="Image.height"></a>const pure @property @safe auto <u id="height">height</u>();
</big></dt>
<dd>Get <u id="height">height</u> of an image.<br><br>

</dd>
<dt><big><a name="Image.depth"></a>const pure @property @safe auto <u id="depth">depth</u>();
</big></dt>
<dd>Get bit <u id="depth">depth</u> of the image.<br><br>

</dd>
<dt><big><a name="Image.empty"></a>const pure @property @safe auto <u id="empty">empty</u>();
</big></dt>
<dd>Check if image is <u id="empty">empty</u> (there's no data present).<br><br>

</dd>
<dt><big><a name="Image.channels"></a>const pure @property @safe auto <u id="channels">channels</u>();
</big></dt>
<dd>Channel count of the image.<br><br>

</dd>
<dt><big><a name="Image.pixelSize"></a>const pure @property @safe auto <u id="pixelSize">pixelSize</u>();
</big></dt>
<dd>Number of bytes contained in one pixel of the image.<br><br>

</dd>
<dt><big><a name="Image.byteSize"></a>const pure @property @safe auto <u id="byteSize">byteSize</u>();
</big></dt>
<dd>Number of bytes contained in the image.<br><br>

</dd>
<dt><big><a name="Image.rowStride"></a>const pure @property @safe auto <u id="rowStride">rowStride</u>();
</big></dt>
<dd>Number of bytes contained in one row of the image.<br><br>

</dd>
<dt><big><a name="Image.size"></a>const pure @property @safe size_t[3] <u id="size">size</u>();
</big></dt>
<dd>Size of the image.
<br><br>
Returns an array of 3 sizes: [width, height, channels]<br><br>

</dd>
<dt><big><a name="Image.isOfType"></a>const pure nothrow @safe bool <u id="isOfType">isOfType</u>(T)();
</big></dt>
<dd>Check if this images data corresponds to given value type.
<br><br>
Given value type is checked against the image data bit depth.
    Data of 8-bit image is considered to be typed as ubyte array,
    16-bit as ushort, and 32-bit as float array. Any other type as
    input returns <b>false</b> result.

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>(template parameter) value type which is tested against the bit depth of the image data.</td></tr>
</table><br>

</dd>
<dt><big><a name="Image.asType"></a>inout auto <u id="asType">asType</u>(T)();
</big></dt>
<dd>Convert image data type to given type.
<br><br>
Creates new image with data typed as given value type.
    If this image's data type is the same as given type, deep
    copy of this image is returned.

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>(template parameter) value type to which image's data is converted.</td></tr>
</table><br>
<b>Returns:</b><br>
Copy of this image with casted data to given type. If given type is same as
        current data of this image, deep copy is returned.<br><br>

</dd>
<dt><big><a name="Image.data"></a>inout pure auto <u id="data">data</u>(T = ubyte)();
</big></dt>
<dd>Get <u id="data">data</u> array from this image.
<br><br>
Cast <u id="data">data</u> array to corresponding dynamic array type,
    and return it.
    8-bit <u id="data">data</u> is considered ubyte, 16-bit ushort, and 32-bit float.

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>(template parameter) value type (default ubyte) to which <u id="data">data</u> array is casted to.</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="asImage"></a>Image <u id="asImage">asImage</u>(size_t N, T)(Slice!(N, T*) <i>slice</i>, ImageFormat <i>format</i>);
</big></dt>
<dd>Convert a ndslice object to an Image, with defined image <i>format</i>.<br><br>

</dd>
<dt><big><a name="asImage.2"></a>Image <u id="asImage">asImage</u>(size_t N, T)(Slice!(N, T*) <i>slice</i>);
</big></dt>
<dd>Convert ndslice object into an image, with default format setup, regarding to <i>slice</i> dimension.<br><br>

</dd>
</dl>

           <hr>Copyright Relja Ljubobratovic 2016.


