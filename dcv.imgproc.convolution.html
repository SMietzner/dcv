<h1>dcv.imgproc.convolution</h1>
           Module introduces <a target="_blank" href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution">image <u id="convolution">convolution</u></a> function.
<br><br>
Following example loads famous image of Lena SÃ¶derberg and performs gaussian blurring by convolving the image with gaussian kernel.
<br><br>

<pre class="d_code"><font color=blue>import</font> dcv.io.image : imread, ReadParams;
<font color=blue>import</font> dcv.core.image : Image, asType;
<font color=blue>import</font> dcv.imgproc.<u id="convolution">convolution</u> : conv;

Image lenaImage = imread(<font color=red>"../data/lena.png"</font>, ReadParams(ImageFormat.IF_MONO, BitDepth.BD_8));
<font color=blue>auto</font> slice = lenaImage.sliced!<font color=blue>ubyte</font>;
</pre>
<br><br>

... this loads the following image:<br>
<img src="https://github.com/libmir/dcv/blob/master/examples/data/lena.png?raw=true"/>
<br><br>

<pre class="d_code">blurred = slice
             .asType!<font color=blue>float</font> <font color=green>// convert ubyte data to float.
</font>             .conv(gaussian!<font color=blue>float</font>(0.84f, 5, 5)); <font color=green>// convolve image with gaussian kernel
</font>
</pre>
<br><br>

... which give the resulting image:<br>
<img src="https://github.com/libmir/dcv/blob/master/examples/filter/result/outblur.png?raw=true"/>
<br><br>


<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.<br><br>

<dl><dt><big><a name="conv"></a>InputTensor <u id="conv">conv</u>(alias bc = neumann, InputTensor, KernelTensor, MaskTensor = KernelTensor)(InputTensor <i>input</i>, KernelTensor <i>kernel</i>, InputTensor <i>prealloc</i> = InputTensor.init, MaskTensor <i>mask</i> = MaskTensor.init, TaskPool <i>pool</i> = taskPool);
</big></dt>
<dd>Perform convolution to given tensor, using given <i>kernel</i>.
Convolution is supported for 1, 2, and 3 dimensional tensors.
<br><br>
<b>Params:</b><br>
<table><tr><td>bc</td>
<td>(Template parameter) Boundary Condition function used while indexing the image matrix.</td></tr>
<tr><td>InputTensor <i>input</i></td>
<td>Input tensor.</td></tr>
<tr><td>KernelTensor <i>kernel</i></td>
<td>Convolution <i>kernel</i> tensor. For 1D <i>input</i>, 1D <i>kernel</i> is expected.
    For 2D <i>input</i>, 2D <i>kernel</i> is expected. For 3D <i>input</i>, 2D or 3D <i>kernel</i> is expected -
    if 2D <i>kernel</i> is given, each item in <i>kernel</i> matrix is applied to each value in
    corresponding 2D coordinate in the <i>input</i>.</td></tr>
<tr><td>InputTensor <i>prealloc</i></td>
<td>Pre-allocated buffer where convolution result can be stored. Default
    value is emptySlice, where resulting array will be newly allocated. Also if
    <i>prealloc</i> is not of same shape as <i>input</i> <i>input</i>, resulting array will be newly allocated.</td></tr>
<tr><td>MaskTensor <i>mask</i></td>
<td>Masking <i>input</i>. Convolution will skip each element where <i>mask</i> is 0. Default value
    is empty slice, which tells that convolution will be performed on the whole <i>input</i>.</td></tr>
<tr><td>TaskPool <i>pool</i></td>
<td>Optional TaskPool instance used to parallelize computation.</td></tr>
</table><br>
<b>Returns:</b><br>
Resulting image after convolution, of same type as <i>input</i> tensor.

<br><br>
<b>Note:</b><br>
Input, <i>mask</i> and pre-allocated slices' strides must be the same.<br><br>

</dd>
</dl>

           <div id="contributors"></div>
           <hr>Copyright Relja Ljubobratovic 2016.


