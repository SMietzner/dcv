<h1>dcv.core.utils</h1>
           Module for various utilities used throughout the library.
<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.<br><br>

<dl><dt><big><a name="emptySlice"></a>pure nothrow @safe Slice!(SliceKind.contiguous, packs, V*) <u id="emptySlice">emptySlice</u>(size_t[] packs, V)();
</big></dt>
<dd>Convenience method to return an empty slice - used mainly as default argument in functions in library.<br><br>

</dd>
<dt><big><a name="staticPack"></a>auto <u id="staticPack">staticPack</u>(size_t CH, SliceKind kind, size_t[] packs, T)(Slice!(kind, packs, T*) <i>slice</i>) if (packs.length == 1);
<br><a name="staticUnpack"></a>auto <u id="staticUnpack">staticUnpack</u>(size_t CH, SliceKind kind, size_t[] packs, T)(Slice!(kind, packs, T[CH]*) <i>slice</i>) if (packs.length == 1);
</big></dt>
<dd>Pack and unpack (N, T*) slices to (N-1, T[M]*).<br><br>

</dd>
<dt><big><a name="clip"></a>pure nothrow @safe T <u id="clip">clip</u>(T, V)(V <i>v</i>) if (isNumeric!V &amp;&amp; isNumeric!T);
</big></dt>
<dd>Clip value by it's value range.
<br><br>
<b>Params:</b><br>
<table><tr><td>V <i>v</i></td>
<td>input value, of the input type</td></tr>
</table><br>
<b>Returns:</b><br>
Clipped value of the output type.<br><br>

</dd>
<dt><big><a name="merge"></a>pure auto <u id="merge">merge</u>(Slices...)(Slices <i>slices</i>) if (Slices.length &gt; 0 &amp;&amp; isSlice!(Slices[0]) &amp;&amp; allSameType!Slices);
</big></dt>
<dd>Merge multiple <i>slices</i> into one.
<br><br>
By input of multiple Slice!(kind, [N], T*) objects, produces one Slice!(kind, [N+1], T*)
 object, where length of last dimension is number of input <i>slices</i>. Values
 of input <i>slices</i>' elements are copied to resulting slice, where [..., i] element
 of j-th input slice is copied to [..., i, j] element of output slice.
<br><br>

 e.g. If three single channel images (Slice!(kind, [2], Iterator)) are merged, output will be
 a three channel image (Slice!(kind, [3], Iterator)).

<br><br>
<b>Params:</b><br>
<table><tr><td>Slices <i>slices</i></td>
<td>Input <i>slices</i>. All must by Slice object with same input template parameters.</td></tr>
</table><br>
<b>Returns:</b><br>
For input of n Slice!(Contiguous, [N], T*) objects, outputs Slice!(kind, [N+1], T*) object, where
 last dimension size is n.<br><br>

</dd>
<dt><big><a name="isBoundaryCondition"></a>enum bool <u id="isBoundaryCondition">isBoundaryCondition</u>(alias bc);
</big></dt>
<dd>Check if given function can perform boundary condition test.<br><br>

</dd>
<dt><big><a name="neumann"></a>auto <u id="neumann">neumann</u>(SliceKind kind, size_t[] packs, Iterator, size_t N)(Slice!(kind, packs, Iterator) <i>tensor</i>, size_t[N] <i>indices</i>...);
</big></dt>
<dd><a href="https://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann</a> boundary condition test<br><br>

</dd>
<dt><big><a name="periodic"></a>auto <u id="periodic">periodic</u>(SliceKind kind, size_t[] packs, Iterator, size_t N)(Slice!(kind, packs, Iterator) <i>tensor</i>, size_t[N] <i>indices</i>...);
</big></dt>
<dd><a href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">Periodic</a> boundary condition test<br><br>

</dd>
<dt><big><a name="symmetric"></a>auto <u id="symmetric">symmetric</u>(SliceKind kind, size_t[] packs, Iterator, size_t N)(Slice!(kind, packs, Iterator) <i>tensor</i>, size_t[N] <i>indices</i>...);
</big></dt>
<dd>Symmetric boundary condition test<br><br>

</dd>
<dt><big><a name="BoundaryConditionTest"></a>template <u id="BoundaryConditionTest">BoundaryConditionTest</u>(SliceKind kind, size_t[] packs, T, size_t N)</big></dt>
<dd>Alias for generalized boundary condition test function.<br><br>

</dd>
</dl>

           <div id="contributors"></div>
           <hr>Copyright Relja Ljubobratovic 2016.


