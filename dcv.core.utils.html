<h1>dcv.core.utils</h1>
           Module for various utilities used throughout the library.
<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.<br><br>

<dl><dt><big><a name="isSlice"></a>enum bool <u id="isSlice">isSlice</u>(T);
</big></dt>
<dd>Check if an type is a Slice.<br><br>

</dd>
<dt><big><a name="emptySlice"></a>pure nothrow @safe Slice!(N, V*) <u id="emptySlice">emptySlice</u>(size_t N, V)();
</big></dt>
<dd>Convenience method to return an empty slice - used mainly as default argument in functions in library.<br><br>

</dd>
<dt><big><a name="staticPack"></a>auto <u id="staticPack">staticPack</u>(size_t CH, size_t N, T)(Slice!(N, T*) <i>slice</i>);
<br><a name="staticUnpack"></a>auto <u id="staticUnpack">staticUnpack</u>(size_t CH, size_t N, T)(Slice!(N, T[CH]*) <i>slice</i>);
</big></dt>
<dd>Pack and unpack (N, T*) slices to (N-1, T[M]*).<br><br>

</dd>
<dt><big><a name="asType"></a>Slice!(N, O*) <u id="asType">asType</u>(O, V, size_t N)(Slice!(N, V*) <i>inslice</i>);
</big></dt>
<dd>Take another typed Slice. Type conversion for the Slice object.
<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(N, V*) <i>inslice</i></td>
<td>Input slice, to be converted to the O type.</td></tr>
</table><br>
<font color=red>Deprecated:</font><br>
In favor of <a target="_blank" href="http://docs.mir.dlang.io/latest/mir_ndslice_slice.html#.as">mir.ndslice.slice.as</a>.

<br><br>
<b>Returns:</b><br>
Return a slice with newly allocated data of type O, with same
    shape as input slice.<br><br>

</dd>
<dt><big><a name="clip"></a>pure nothrow @safe T <u id="clip">clip</u>(T, V)(V <i>v</i>) if (isNumeric!V &amp;&amp; isNumeric!T);
</big></dt>
<dd>Clip value by it's value range.
<br><br>
<b>Params:</b><br>
<table><tr><td>V <i>v</i></td>
<td>input value, of the input type</td></tr>
</table><br>
<b>Returns:</b><br>
Clipped value of the output type.<br><br>

</dd>
<dt><big><a name="merge"></a>pure auto <u id="merge">merge</u>(Slices...)(Slices <i>slices</i>) if (Slices.length &gt; 0 &amp;&amp; isSlice!(Slices[0]) &amp;&amp; allSameType!Slices);
</big></dt>
<dd>Merge multiple <i>slices</i> into one.
<br><br>
By input of multiple Slice!(N, T*) objects, produces one Slice!(N+1, T*)
 object, where length of last dimension is number of input <i>slices</i>. Values
 of input <i>slices</i>' elements are copied to resulting slice, where [..., i] element
 of j-th input slice is copied to [..., i, j] element of output slice.
<br><br>

 e.g. If three single channel images (Slice!(2, T*)) are merged, output will be
 a three channel image (Slice!(3, T*)).

<br><br>
<b>Params:</b><br>
<table><tr><td>Slices <i>slices</i></td>
<td>Input <i>slices</i>. All must by Slice object with same input template parameters.</td></tr>
</table><br>
<b>Returns:</b><br>
For input of n Slice!(N, T*) objects, outputs Slice!(N+1, T*) object, where
 last dimension size is n.<br><br>

</dd>
<dt><big><a name="isBoundaryCondition"></a>enum bool <u id="isBoundaryCondition">isBoundaryCondition</u>(alias bc);
</big></dt>
<dd>Check if given function can perform boundary condition test.<br><br>

</dd>
<dt><big><a name="neumann"></a>auto <u id="neumann">neumann</u>(Tensor, Indices...)(Tensor <i>tensor</i>, Indices <i>indices</i>) if (isSlice!Tensor &amp;&amp; allSameType!Indices &amp;&amp; allSatisfy!(isIntegral, Indices));
</big></dt>
<dd><a href="https://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann</a> boundary condition test<br><br>

</dd>
<dt><big><a name="periodic"></a>auto <u id="periodic">periodic</u>(Tensor, Indices...)(Tensor <i>tensor</i>, Indices <i>indices</i>) if (isSlice!Tensor &amp;&amp; allSameType!Indices &amp;&amp; allSatisfy!(isIntegral, Indices));
</big></dt>
<dd><a href="https://en.wikipedia.org/wiki/Periodic_boundary_conditions">Periodic</a> boundary condition test<br><br>

</dd>
<dt><big><a name="symmetric"></a>auto <u id="symmetric">symmetric</u>(Tensor, Indices...)(Tensor <i>tensor</i>, Indices <i>indices</i>) if (isSlice!Tensor &amp;&amp; allSameType!Indices &amp;&amp; allSatisfy!(isIntegral, Indices));
</big></dt>
<dd>Symmetric boundary condition test<br><br>

</dd>
<dt><big><a name="BoundaryConditionTest"></a>template <u id="BoundaryConditionTest">BoundaryConditionTest</u>(size_t N, T, Indices...)</big></dt>
<dd>Alias for generalized boundary condition test function.<br><br>

</dd>
</dl>

           <div id="contributors"></div>
           <hr>Copyright Relja Ljubobratovic 2016.


