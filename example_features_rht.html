<h1 id="randomized-hough-transform-rht">Randomized Hough Transform (RHT)</h1>
<p><em>â€¦ by <a href="https://github.com/DmitryOlshansky">Dmitry Olshansky</a></em></p>
<p>This example should demonstrate how to use Randomized Hough Transform to detect shapes in images. Should showcases a few basics such as image i/o, conversion to Slice object etc.</p>
<h2 id="modules-used">Modules used</h2>
<ul>
<li>dcv.core.image</li>
<li>dcv.core.utils</li>
<li>dcv.io</li>
<li>dcv.imgproc</li>
<li>dcv.features.rht</li>
</ul>
<h2 id="source-image">Source Image</h2>
<p>As source image in this example is a bunch of geometic shapes (img.png). Source data is loaded with next chunk of code:</p>
<div><pre style="margin: 0; line-height: 125%">string impath = (args.length &lt; 2) ? <span style="color: #a31515">&quot;../data/img.png&quot;</span> : args[1];

Image img = imread(impath); <span style="color: #008000">// read an image from filesystem.</span>

<span style="color: #0000ff">if</span> (img.empty) { <span style="color: #008000">// check if image is properly read.</span>
    writeln(<span style="color: #a31515">&quot;Cannot read image at: &quot;</span> ~ impath);
    <span style="color: #0000ff">return</span> 1;
}

Slice!(3, <span style="color: #2b91af">float</span>*) imslice = img
    .asType!<span style="color: #2b91af">float</span> <span style="color: #008000">// convert Image data type from ubyte to float</span>
    .sliced!<span style="color: #2b91af">float</span>; <span style="color: #008000">// slice image data - calls img.data!float.sliced(img.height, img.width, img.channels)</span>
</pre></div>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/data/img.png?raw=true" alt="alt tag" />
</div>
<h2 id="gaussian-blurring">Gaussian Blurring</h2>
<p>Classic gaussian kernel is created using <code>dcv.imgproc.filter.gaussian</code> function. By convolving an image with created kernel, we filter out potential noise in the image.</p>
<h3 id="code">Code</h3>
<p>We create gaussian (2D) kernel with sigma value of 2.0, of size 5x5, and then we convolve the image with it:</p>
<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">auto</span> gaussianKernel = gaussian!<span style="color: #2b91af">float</span>(2, 5, 5);
<span style="color: #0000ff">auto</span> blur = imslice.conv(gaussianKernel);
</pre></div>
<h3 id="result">Result</h3>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/rht/result/outblur.png?raw=true" alt="alt tag" />
</div>
<h2 id="edge-detection">Edge Detection</h2>
<p>In this example, we apply classic Canny filter to detect edges:</p>
<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">auto</span> canny = blur.canny!<span style="color: #2b91af">ubyte</span>(80);
</pre></div>
<h3 id="result-1">Result</h3>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/rht/result/canny.png?raw=true" alt="alt tag" />
</div>
<h2 id="randomized-hough-transform-rht">Randomized Hough Transform (RHT)</h2>
<h3 id="rht-for-lines">RHT for lines</h3>
<p>Next step is to setup RHT context with key parameters that affect fundamental properties such as time vs accuracy trade-off. The most important are <code>epouchs</code> - number of attempts to detect a shape, and <code>iterations</code> - number of steps in each attempt. Small number of iterations leads to poor accuracy, too high a number wastes a lot of CPU cycles. Since not every attempt is successul (being randomized method) the number of epouchs is advised to be 2-4 times larger than the number of expected shapes. <code>minCurve</code> parameter allows to filter out degenerate shapes with too few pixels, here we require at least 25 pixels in a shape:</p>
<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">auto</span> lines = RhtLines().epouchs(50).iterations(250).minCurve(25);
</pre></div>
<p>Apply method and iterate the lazily computating shapes:</p>
<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">foreach</span>(line; linesRange) {
    writeln(line);
    plotLine(imslice, line, [1.0, 1.0, 1.0]);
}
</pre></div>
<p>It is therefore easy to compute just enough of epouchs to get the first few likely shapes.</p>
<h3 id="rht-for-circles">RHT for circles</h3>
<p>Simillar setup is performed for RHT context for circles, using familliar key parameters.</p>
<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">auto</span> circles = RhtCircles().epouchs(5).iterations(2000).minCurve(16);
</pre></div>
<p>One twist is application of circle RHT, this time around we use it only on points left off after filtering out lines. This is especially useful filtering technique in pictures where circles is a minory compared to simple lines. Accessing filtered points has other use cases such as reconstructing the scene with some shapes removed.</p>
<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">foreach</span>(circle; circles(canny, linesRange.points[])) {
    writeln(circle);
    plotCircle(imslice, circle, [1.0, 1.0, 1.0]);
}
</pre></div>
<h3 id="result">Result</h3>
<div class="figure">
<img src="https://github.com/ljubobratovicrelja/dcv/blob/master/examples/rht/result/rht.png?raw=true" alt="alt tag" />
</div>

<br><br><span><big>Complete code:</big></span><br><br>

<div><pre style="margin: 0; line-height: 125%"><span style="color: #0000ff">module</span> dcv.example.rht;

<span style="color: #008000">/** </span>
<span style="color: #008000"> * Randomized Hough Transform example using dcv library.</span>
<span style="color: #008000"> */</span>

<span style="color: #0000ff">import</span> std.experimental.ndslice;
<span style="color: #0000ff">import</span> std.stdio : writeln;
<span style="color: #0000ff">import</span> std.datetime : StopWatch;
<span style="color: #0000ff">import</span> std.math : fabs, PI, sin, cos, rint;
<span style="color: #0000ff">import</span> std.typecons : tuple;

<span style="color: #0000ff">import</span> dcv.core : Image, asType, ranged, ImageFormat;
<span style="color: #0000ff">import</span> dcv.io : imread, imwrite;
<span style="color: #0000ff">import</span> dcv.imgproc;
<span style="color: #0000ff">import</span> dcv.features.rht;

<span style="color: #2b91af">void</span> plotLine(T, Line, Color)(Slice!(3, T*) img, Line line, Color color)
{
    <span style="color: #2b91af">int</span> height = <span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) img.length!0;
    <span style="color: #2b91af">int</span> width = <span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) img.length!1;
    <span style="color: #0000ff">if</span> (line.m == <span style="color: #2b91af">double</span>.infinity)
    {
        <span style="color: #0000ff">auto</span> x = line.b;
        <span style="color: #0000ff">if</span> (x &gt;= 0 &amp;&amp; x &lt; width)
            <span style="color: #0000ff">foreach</span> (y; 0 .. height)
            {
                img[<span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) y, <span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) x, 0 .. 3] = color;
            }
    }
    <span style="color: #0000ff">else</span>
    {
        <span style="color: #0000ff">foreach</span> (x; 0 .. 1000)
        {
            <span style="color: #0000ff">auto</span> y = line.m * x + line.b;
            <span style="color: #0000ff">if</span> (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height)
            {
                img[<span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) y, <span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) x, 0 .. 3] = color;
            }
        }
    }
}

<span style="color: #2b91af">void</span> plotCircle(T, Circle, Color)(Slice!(3, T*) img, Circle circle, Color color)
{
    <span style="color: #2b91af">int</span> height = <span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) img.length!0;
    <span style="color: #2b91af">int</span> width = <span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) img.length!1;
    <span style="color: #008000">// quick and dirty circle plot</span>
    <span style="color: #0000ff">foreach</span> (t; 0 .. 360)
    {
        <span style="color: #2b91af">int</span> x = <span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) rint(circle.x + circle.r * cos(t * PI / 180));
        <span style="color: #2b91af">int</span> y = <span style="color: #0000ff">cast</span>(<span style="color: #2b91af">int</span>) rint(circle.y + circle.r * sin(t * PI / 180));
        <span style="color: #0000ff">if</span> (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height)
            img[y, x, 0 .. 3] = color;
    }
}

<span style="color: #2b91af">int</span> main(string[] args)
{

    string impath = (args.length &lt; 2) ? <span style="color: #a31515">&quot;../data/img.png&quot;</span> : args[1];

    Image img = imread(impath); <span style="color: #008000">// read an image from filesystem.</span>

    <span style="color: #0000ff">if</span> (img.empty)
    { <span style="color: #008000">// check if image is properly read.</span>
        writeln(<span style="color: #a31515">&quot;Cannot read image at: &quot;</span> ~ impath);
        <span style="color: #0000ff">return</span> 1;
    }

    Slice!(3, <span style="color: #2b91af">float</span>*) imslice = img.asType!<span style="color: #2b91af">float</span> <span style="color: #008000">// convert Image data type from ubyte to float</span>
    .sliced!<span style="color: #2b91af">float</span>; <span style="color: #008000">// slice image data - calls img.data!float.sliced(img.height, img.width, img.channels)</span>

    <span style="color: #0000ff">auto</span> gray = imslice.rgb2gray; <span style="color: #008000">// convert rgb image to grayscale</span>

    <span style="color: #0000ff">auto</span> gaussianKernel = gaussian!<span style="color: #2b91af">float</span>(2, 3, 3); <span style="color: #008000">// create gaussian convolution kernel (sigma, kernel width and height)</span>

    <span style="color: #0000ff">auto</span> blur = gray.conv(gaussianKernel);
    <span style="color: #0000ff">auto</span> canny = blur.canny!<span style="color: #2b91af">ubyte</span>(80);

    <span style="color: #0000ff">auto</span> lines = RhtLines().epouchs(50).iterations(250).minCurve(25);
    StopWatch s;
    s.start;
    <span style="color: #0000ff">auto</span> linesRange = lines(canny);
    <span style="color: #0000ff">foreach</span> (line; linesRange)
    {
        writeln(line);
        plotLine(imslice, line, [1.0, 1.0, 1.0]);
    }
    s.stop;
    writeln(<span style="color: #a31515">&quot;RHT lines took &quot;</span>, s.peek.msecs, <span style="color: #a31515">&quot;ms&quot;</span>);
    writeln(<span style="color: #a31515">&quot;Points left after lines:&quot;</span>, linesRange.points.length);
    <span style="color: #0000ff">auto</span> circles = RhtCircles().epouchs(5).iterations(2000).minCurve(16);
    s.reset;
    s.start;
    <span style="color: #0000ff">foreach</span> (circle; circles(canny, linesRange.points[]))
    {
        writeln(circle);
        plotCircle(imslice, circle, [1.0, 1.0, 1.0]);
    }
    s.stop;
    writeln(<span style="color: #a31515">&quot;RHT circles took &quot;</span>, s.peek.msecs, <span style="color: #a31515">&quot;ms&quot;</span>);

    <span style="color: #008000">// write resulting images on the filesystem.</span>
    blur.asType!<span style="color: #2b91af">ubyte</span>.imwrite(ImageFormat.IF_RGB, <span style="color: #a31515">&quot;./result/outblur.png&quot;</span>);
    canny.asType!<span style="color: #2b91af">ubyte</span>.imwrite(ImageFormat.IF_MONO, <span style="color: #a31515">&quot;./result/canny.png&quot;</span>);
    imslice.asType!<span style="color: #2b91af">ubyte</span>.imwrite(ImageFormat.IF_RGB, <span style="color: #a31515">&quot;./result/rht.png&quot;</span>);

    <span style="color: #0000ff">return</span> 0;
}
</pre></div>
