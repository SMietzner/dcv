<h1>dcv.imgproc.color</h1>
           Module contains <u id="color">color</u> format convertion operations.
<br><br>
<dl>Module contains:
    <dd>            <a href="#rgb2gray">rgb2gray</a>
            <a href="#gray2rgb">gray2rgb</a>
            <a href="#rgb2hsv">rgb2hsv</a>
            <a href="#hsv2rgb">hsv2rgb</a>
            <a href="#rgb2yuv">rgb2yuv</a>
            <a href="#yuv2rgb">yuv2rgb</a>
    </dd>
</dl>

<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.<br><br>

<dl><dt><big><a name="Rgb2GrayConvertion"></a>enum <u id="Rgb2GrayConvertion">Rgb2GrayConvertion</u>: int;
</big></dt>
<dd>RGB to Grayscale convertion strategy.<br><br>

<dl><dt><big><a name="Rgb2GrayConvertion.MEAN"></a><u id="MEAN">MEAN</u></big></dt>
<dd>Mean the RGB values and assign to gray.<br><br>

</dd>
<dt><big><a name="Rgb2GrayConvertion.LUMINANCE_PRESERVE"></a><u id="LUMINANCE_PRESERVE">LUMINANCE_PRESERVE</u></big></dt>
<dd>Use luminance preservation (0.2126R + 0.715G + 0.0722B).<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="rgb2gray"></a>pure nothrow Slice!(SliceKind.contiguous, [2], V*) <u id="rgb2gray">rgb2gray</u>(V)(Slice!(SliceKind.contiguous, [3], V*) <i>input</i>, Slice!(SliceKind.contiguous, [2], V*) <i>prealloc</i> = emptySlice!([2], V), Rgb2GrayConvertion <i>conv</i> = Rgb2GrayConvertion.LUMINANCE_PRESERVE);
</big></dt>
<dd>Convert RGB image to grayscale.
<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>input</i></td>
<td>Input image. Should have 3 channels, represented as R, G and B
        respectively in that order.</td></tr>
<tr><td>Slice!(SliceKind.contiguous, [2], V*) <i>prealloc</i></td>
<td>Pre-allocated buffer, where grayscale image will be copied. Default
    argument is an empty slice, where new data is allocated and returned. If given
    slice is not of corresponding shape(range.shape[0], range.shape[1]), it is
    discarded and allocated anew.</td></tr>
<tr><td>Rgb2GrayConvertion <i>conv</i></td>
<td>Convertion strategy - mean, or luminance preservation.</td></tr>
</table><br>
<b>Returns:</b><br>
Returns grayscale version of the given RGB image, of the same size.

<br><br>
<b>Note:</b><br>
Input and pre-allocated slices' strides must be identical.<br><br>

</dd>
<dt><big><a name="bgr2gray"></a>pure nothrow Slice!(SliceKind.contiguous, [2], V*) <u id="bgr2gray">bgr2gray</u>(V)(Slice!(SliceKind.contiguous, [3], V*) <i>input</i>, Slice!(SliceKind.contiguous, [2], V*) <i>prealloc</i> = emptySlice!([2], V), Rgb2GrayConvertion <i>conv</i> = Rgb2GrayConvertion.LUMINANCE_PRESERVE);
</big></dt>
<dd>Convert BGR image to grayscale.
<br><br>
Same as rgb2gray, but follows swapped channels if luminance preservation
is chosen as convertion strategy.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>input</i></td>
<td>Input image. Should have 3 channels, represented as B, G and R
        respectively in that order.</td></tr>
<tr><td>Slice!(SliceKind.contiguous, [2], V*) <i>prealloc</i></td>
<td>Pre-allocated range, where grayscale image will be copied. Default
    argument is an empty slice, where new data is allocated and returned. If given
    slice is not of corresponding shape(range.shape[0], range.shape[1]), it is
    discarded and allocated anew.</td></tr>
<tr><td>Rgb2GrayConvertion <i>conv</i></td>
<td>Convertion strategy - mean, or luminance preservation.</td></tr>
</table><br>
<b>Returns:</b><br>
Returns grayscale version of the given BGR image, of the same size.

<br><br>
<b>Note:</b><br>
Input and pre-allocated slices' strides must be identical.<br><br>

</dd>
<dt><big><a name="gray2rgb"></a>pure nothrow Slice!(SliceKind.contiguous, [3], V*) <u id="gray2rgb">gray2rgb</u>(V)(Slice!(SliceKind.contiguous, [2], V*) <i>input</i>, Slice!(SliceKind.contiguous, [3], V*) <i>prealloc</i> = emptySlice!([3], V));
</big></dt>
<dd>Convert gray image to RGB.
<br><br>
Uses grayscale value and assigns it's value
to each of three channels for the RGB image version.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(SliceKind.contiguous, [2], V*) <i>input</i></td>
<td>Grayscale image, to be converted to the RGB.</td></tr>
<tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>prealloc</i></td>
<td>Pre-allocated range, where RGB image will be copied. Default
    argument is an empty slice, where new data is allocated and returned. If given
    slice is not of corresponding shape(range.shape[0], range.shape[1], 3), it is
    discarded and allocated anew.</td></tr>
</table><br>
<b>Returns:</b><br>
Returns RGB version of the given grayscale image.

<br><br>
<b>Note:</b><br>
Input and pre-allocated slices' strides must be identical.<br><br>

</dd>
<dt><big><a name="rgb2hsv"></a>pure nothrow Slice!(SliceKind.contiguous, [3], R*) <u id="rgb2hsv">rgb2hsv</u>(R, V)(Slice!(SliceKind.contiguous, [3], V*) <i>input</i>, Slice!(SliceKind.contiguous, [3], R*) <i>prealloc</i> = emptySlice!([3], R)) if (isNumeric!R &amp;&amp; isNumeric!V);
</big></dt>
<dd>Convert RGB image to HSV color format.
<br><br>
If HSV is represented as floating point, H is
represented as 0-360 (degrees), S and V are 0.0-1.0.
If is integral, S, and V are 0-100.
<br><br>

Depending on the RGB (<i>input</i>) type, values are treated in the
algorithm to be ranged as 0-255 for ubyte, 0-65535 for ushort,
and 0-1 for floating point types.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>input</i></td>
<td>RGB image, which gets converted to HSV.</td></tr>
<tr><td>Slice!(SliceKind.contiguous, [3], R*) <i>prealloc</i></td>
<td>Pre-allocated range, where HSV image will be copied. Default
    argument is an empty slice, where new data is allocated and returned. If given
    slice is not of corresponding shape(range.shape[0], range.shape[1], 3), it is
    discarded and allocated anew.</td></tr>
</table><br>
<b>Returns:</b><br>
Returns HSV verion of the given RGB image.

<br><br>
<b>Note:</b><br>
Input and pre-allocated slices' strides must be identical.<br><br>

</dd>
<dt><big><a name="hsv2rgb"></a>pure nothrow Slice!(SliceKind.contiguous, [3], R*) <u id="hsv2rgb">hsv2rgb</u>(R, V)(Slice!(SliceKind.contiguous, [3], V*) <i>input</i>, Slice!(SliceKind.contiguous, [3], R*) <i>prealloc</i> = emptySlice!([3], R)) if (isNumeric!R &amp;&amp; isNumeric!V);
</big></dt>
<dd>Convert HSV image to RGB color format.
<br><br>
If HSV is represented in floating point, H is 0-360 degrees, S and V is 0.0-1.0.
If it's of integral type, S and V values are in 0-100 range.
<br><br>

Output range values are based on the output type cast - ubyte will
range RGB values to be 0-255, ushort 0-65535, and floating types
0.0-1.0. Other types are not supported.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>input</i></td>
<td>HSV image, which gets converted to RGB.</td></tr>
<tr><td>Slice!(SliceKind.contiguous, [3], R*) <i>prealloc</i></td>
<td>Pre-allocated range, where RGB image will be copied. Default
    argument is an empty slice, where new data is allocated and returned. If given
    slice is not of corresponding shape(range.shape[0], range.shape[1], 3), it is
    discarded and allocated anew.</td></tr>
</table><br>
<b>Returns:</b><br>
Returns RGB verion of the given HSV image.

<br><br>
<b>Note:</b><br>
Input and pre-allocated slices' strides must be identical.<br><br>

</dd>
<dt><big><a name="rgb2yuv"></a>pure nothrow Slice!(SliceKind.contiguous, [3], V*) <u id="rgb2yuv">rgb2yuv</u>(V)(Slice!(SliceKind.contiguous, [3], V*) <i>input</i>, Slice!(SliceKind.contiguous, [3], V*) <i>prealloc</i> = emptySlice!([3], V));
</big></dt>
<dd>Convert RGB image format to YUV.
<br><br>
YUV images in dcv are organized in the same buffer plane
where quantity of luma and chroma values are the same (as in
YUV444 format).

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>input</i></td>
<td>Input RGB image.</td></tr>
<tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>prealloc</i></td>
<td>Optional pre-allocated buffer. If given, has to be
        of same shape as <i>input</i> image, otherwise gets reallocated.</td></tr>
</table><br>
<b>Returns:</b><br>
Resulting YUV image slice.

<br><br>
<b>Note:</b><br>
Input and pre-allocated slices' strides must be identical.<br><br>

</dd>
<dt><big><a name="yuv2rgb"></a>pure nothrow Slice!(SliceKind.contiguous, [3], V*) <u id="yuv2rgb">yuv2rgb</u>(V)(Slice!(SliceKind.contiguous, [3], V*) <i>input</i>, Slice!(SliceKind.contiguous, [3], V*) <i>prealloc</i> = emptySlice!([3], V));
</big></dt>
<dd>Convert YUV image to RGB.
<br><br>
As in rgb2yuv conversion, YUV format is considered to have
same amount of luma and chroma.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>input</i></td>
<td>Input YUV image.</td></tr>
<tr><td>Slice!(SliceKind.contiguous, [3], V*) <i>prealloc</i></td>
<td>Optional pre-allocated buffer. If given, has to be
        of same shape as <i>input</i> image, otherwise gets reallocated.</td></tr>
</table><br>
<b>Returns:</b><br>
Resulting RGB image slice.

<br><br>
<b>Note:</b><br>
Input and pre-allocated slices' strides must be identical.<br><br>

</dd>
</dl>

           <div id="contributors"></div>
           <hr>Copyright Relja Ljubobratovic 2016.


