<h1>dcv.imgproc.imgmanip</h1>
           Image manipulation module.
<br><br>
<b>Authors:</b><br>
Relja Ljubobratovic

<br><br>
<b>License:</b><br>
<a target="_blank" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License - Version 1.0</a>.
<br><br>

<dl>Module contains:
    <dd>            <a href="#resize">resize</a>
            <a href="#scale">scale</a>
            <a href="#transformAffine">transformAffine</a>
            <a href="#transformPerspective">transformPerspective</a>
            <a href="#warp">warp</a>
            <a href="#remap">remap</a>
    </dd>
</dl><br><br>

<dl><dt><big><a name="resize"></a>Slice!(SliceKind.contiguous, packs, V*) <u id="resize">resize</u>(alias interp = linear, SliceKind kind, size_t[] packs, V, size_t SN)(Slice!(kind, packs, V*) <i>slice</i>, size_t[SN] <i>newsize</i>, TaskPool <i>pool</i> = taskPool) if (packs.length == 1);
</big></dt>
<dd>Resize array using custom interpolation function.
<br><br>
Primarilly implemented as image <u id="resize">resize</u>.
1D, 2D and 3D arrays are supported, where 3D array is
treated as channeled image - each channel is interpolated
as isolated 2D array (matrix).
<br><br>

Interpolation function is given as a template parameter.
Default interpolation function is linear. Custom interpolation
function can be implemented in the 3rd party code, by following
interpolation function rules in dcv.imgproc.interpolation.

<br><br>
<b>Params:</b><br>
<table><tr><td>Slice!(kind, packs, V*) <i>slice</i></td>
<td>Slice to an input array.</td></tr>
<tr><td>size_t[SN] <i>newsize</i></td>
<td>tuple that defines new shape. New dimension has to be
    the same as input <i>slice</i> in the 1D and 2D <u id="resize">resize</u>, where in the
    3D <u id="resize">resize</u> <i>newsize</i> has to be 2D.</td></tr>
<tr><td>TaskPool <i>pool</i></td>
<td>Optional TaskPool instance used to parallelize computation.</td></tr>
</table><br>
<b>TODO:</b><br>
consider size input as array, and add prealloc<br><br>

</dd>
<dt><big><a name="scale"></a>Slice!(kind, packs, V*) <u id="scale">scale</u>(alias interp = linear, V, ScaleValue, SliceKind kind, size_t[] packs, size_t SN)(Slice!(kind, packs, V*) <i>slice</i>, ScaleValue[SN] <u id="scale">scale</u>, TaskPool <i>pool</i> = taskPool) if (isFloatingPoint!ScaleValue &amp;&amp; isInterpolationFunc!interp);
</big></dt>
<dd>Scale array size using custom interpolation function.
<br><br>
Implemented as convenience function which calls resize
using scaled shape of the input <i>slice</i> as:
<br><br>

<pre class="d_code">scaled = resize(input, input.shape*<u id="scale">scale</u>)</pre><br><br>

</dd>
<dt><big><a name="warp"></a>pure auto <u id="warp">warp</u>(alias interp = linear, ImageTensor, MapTensor)(ImageTensor <i>image</i>, MapTensor <i>map</i>, ImageTensor <i>prealloc</i> = ImageTensor.init);
</big></dt>
<dd>Pixel-wise warping of the <i>image</i>.
<br><br>
Displace each pixel of an <i>image</i> by given [x, y] values.

<br><br>
<b>Params:</b><br>
<table><tr><td>interp</td>
<td>(template parameter) Interpolation function, default linear.</td></tr>
<tr><td>ImageTensor <i>image</i></td>
<td>Input <i>image</i>, which is warped. Single and multiple channel images are allowed.</td></tr>
<tr><td>MapTensor <i>map</i></td>
<td>Displacement <i>map</i>, which holds [x, y] displacement for each pixel of an <i>image</i>.</td></tr>
<tr><td>ImageTensor <i>prealloc</i></td>
<td>Pre-allocated memory where resulting warped <i>image</i> is stored, if defined.
    Should be of same shape as input <i>image</i>, or an emptySlice, which implies newly allocated <i>image</i> is used.</td></tr>
</table><br>
<b>Returns:</b><br>
Warped input <i>image</i> by given <i>map</i>.<br><br>

</dd>
<dt><big><a name="remap"></a>pure auto <u id="remap">remap</u>(alias interp = linear, ImageTensor, MapTensor)(ImageTensor <i>image</i>, MapTensor <i>map</i>, ImageTensor <i>prealloc</i> = ImageTensor.init);
</big></dt>
<dd>Pixel-wise remapping of the <i>image</i>.
<br><br>
Move each pixel of an <i>image</i> to a given [x, y] location defined by the <i>map</i>.
Function is similar to dcv.imgproc.imgmanip.warp, except displacement of pixels
is absolute, rather than relative.

<br><br>
<b>Params:</b><br>
<table><tr><td>interp</td>
<td>(template parameter) Interpolation function, default linear.</td></tr>
<tr><td>ImageTensor <i>image</i></td>
<td>Input <i>image</i>, which is remapped. Single and multiple channel images are allowed.</td></tr>
<tr><td>MapTensor <i>map</i></td>
<td>Target <i>map</i>, which holds [x, y] position for each pixel of an <i>image</i>.</td></tr>
<tr><td>ImageTensor <i>prealloc</i></td>
<td>Pre-allocated memory where resulting remapped <i>image</i> is stored, if defined.
    Should be of same shape as input <i>image</i>, or an emptySlice, which implies newly allocated <i>image</i> is used.</td></tr>
</table><br>
<b>Returns:</b><br>
Remapped input <i>image</i> by given <i>map</i>.<br><br>
<b>Examples:</b><br>
Test if warp and <u id="remap">remap</u> always returns slice of corresponding format.
<pre class="d_code">
<font color=blue>import</font> std.random : uniform01;
<font color=blue>import</font> mir.ndslice.allocation;

<font color=blue>auto</font> <i>image</i> = iota(3, 3).as!<font color=blue>float</font>.slice;
<font color=blue>auto</font> wmap = iota(3, 3, 2).<i>map</i>!(v =&gt; <font color=blue>cast</font>(<font color=blue>float</font>)uniform01).slice;

<font color=blue>auto</font> warped = <i>image</i>.warp(wmap);
<font color=blue>assert</font>(warped.shape == <i>image</i>.shape);

<font color=blue>auto</font> remapped = <i>image</i>.<u id="remap">remap</u>(wmap);
<font color=blue>assert</font>(remapped.shape == <i>image</i>.shape);
</pre>
<br><br>
</dd>
<dt><big><a name="transformAffine"></a>Slice!(kind, packs, V*) <u id="transformAffine">transformAffine</u>(alias interp = linear, V, TransformMatrix, SliceKind kind, size_t[] packs)(Slice!(kind, packs, V*) <i>slice</i>, inout TransformMatrix <i>transform</i>, size_t[2] <i>outSize</i> = [0, 0]);
</big></dt>
<dd>Transform an image by given affine transformation.
<br><br>
<b>Params:</b><br>
<table><tr><td>interp</td>
<td>(template parameter) Interpolation function. Default linear.</td></tr>
<tr><td>Slice!(kind, packs, V*) <i>slice</i></td>
<td>Slice of an image which is transformed.</td></tr>
<tr><td>TransformMatrix <i>transform</i></td>
<td>2D Transformation matrix (3x3). Its element type must be floating point type,
    and it can be defined as Slice object, dynamic or static 2D array.</td></tr>
<tr><td>size_t[2] <i>outSize</i></td>
<td>Output image size - if transformation potentially moves parts of image out
    of input image bounds, output image can be sized differently to maintain information.</td></tr>
</table><br>
<b>Note:</b><br>
Given transformation is considered to be an affine transformation. If it is not, result is undefined.

<br><br>
<b>Returns:</b><br>
Transformed image.<br><br>

</dd>
<dt><big><a name="transformPerspective"></a>Slice!(kind, packs, V*) <u id="transformPerspective">transformPerspective</u>(alias interp = linear, V, TransformMatrix, SliceKind kind, size_t[] packs)(Slice!(kind, packs, V*) <i>slice</i>, TransformMatrix <i>transform</i>, size_t[2] <i>outSize</i> = [0, 0]);
</big></dt>
<dd>Transform an image by given perspective transformation.
<br><br>
<b>Params:</b><br>
<table><tr><td>interp</td>
<td>(template parameter) Interpolation function. Default linear.</td></tr>
<tr><td>Slice!(kind, packs, V*) <i>slice</i></td>
<td>Slice of an image which is transformed.</td></tr>
<tr><td>TransformMatrix <i>transform</i></td>
<td>2D Transformation matrix (3x3). Its element type must be floating point type,
    and it can be defined as Slice object, dynamic or static 2D array.</td></tr>
<tr><td>size_t[2] <i>outSize</i></td>
<td>Output image size [width, height] - if transformation potentially moves parts of image out
    of input image bounds, output image can be sized differently to maintain information.</td></tr>
</table><br>
<b>Note:</b><br>
Given transformation is considered to be an perspective transformation. If it is not, result is undefined.

<br><br>
<b>Returns:</b><br>
Transformed image.<br><br>

</dd>
</dl>

           <div id="contributors"></div>
           <hr>Copyright Relja Ljubobratovic 2016.


